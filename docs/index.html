<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8x8 Strategy Arena</title>
    <style>
        :root {
            --bg-dark: #0f0f1a;
            --bg-panel: #1a1a2e;
            --bg-card: #16213e;
            --accent: #e94560;
            --accent-light: #ff6b6b;
            --accent-green: #4ecdc4;
            --accent-gold: #ffd93d;
            --text: #eee;
            --text-dim: #888;
            --text-muted: #555;
            --cell-empty: #2a2a4a;
            --cell-filled: #4ecdc4;
            --border: rgba(255,255,255,0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            font-size: 14px;
        }
        header {
            background: var(--bg-panel);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }
        h1 { font-size: 1.3rem; color: var(--text); font-weight: 600; }
        .subtitle { color: var(--text-dim); font-size: 0.8rem; }
        .container {
            display: grid;
            grid-template-columns: 280px 1fr 260px;
            height: calc(100vh - 50px);
        }
        .sidebar {
            background: var(--bg-panel);
            padding: 16px;
            border-right: 1px solid var(--border);
            overflow-y: auto;
        }
        .section { margin-bottom: 20px; }
        .section-header {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 10px;
            font-weight: 600;
        }
        .mode-selector {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
        }
        .mode-option {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
        .mode-option:hover { background: rgba(255,255,255,0.03); }
        .mode-option.selected { border-color: var(--accent); background: rgba(233,69,96,0.1); }
        .mode-radio {
            width: 16px; height: 16px;
            border: 2px solid var(--text-dim);
            border-radius: 50%;
            margin-top: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mode-option.selected .mode-radio { border-color: var(--accent); }
        .mode-option.selected .mode-radio::after {
            content: '';
            width: 8px; height: 8px;
            background: var(--accent);
            border-radius: 50%;
        }
        .mode-info { flex: 1; }
        .mode-name { font-weight: 600; margin-bottom: 2px; }
        .mode-desc { font-size: 0.75rem; color: var(--text-dim); line-height: 1.4; }
        .strategy-list { max-height: 320px; overflow-y: auto; }
        .strategy-item {
            padding: 10px 12px;
            margin-bottom: 6px;
            background: var(--bg-card);
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.15s;
        }
        .strategy-item:hover { border-color: var(--text-muted); }
        .strategy-item.selected { border-color: var(--accent-green); background: rgba(78,205,196,0.1); }
        .strategy-header { display: flex; justify-content: space-between; align-items: center; }
        .strategy-name { font-weight: 600; font-size: 0.9rem; }
        .strategy-category {
            font-size: 0.65rem;
            padding: 2px 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            color: var(--text-dim);
        }
        .strategy-short { font-size: 0.75rem; color: var(--text-dim); margin-top: 4px; }
        .strategy-detail {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            font-size: 0.72rem;
            color: var(--text-dim);
            line-height: 1.5;
        }
        .strategy-item.expanded .strategy-detail { display: block; }
        .strategy-complexity { margin-top: 6px; font-family: monospace; color: var(--accent-green); }
        .control-row { display: flex; gap: 8px; margin-bottom: 12px; }
        .control-group { flex: 1; }
        label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-card);
            color: var(--text);
            font-size: 0.85rem;
        }
        button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-light); }
        .btn-primary:disabled { background: var(--text-muted); cursor: not-allowed; }
        .btn-secondary { background: var(--bg-card); color: var(--text); margin-top: 8px; border: 1px solid var(--border); }
        .progress-bar { height: 3px; background: var(--bg-card); border-radius: 2px; margin-top: 12px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.3s; }
        main { padding: 16px; overflow-y: auto; background: var(--bg-dark); }
        .battle-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 14px; }
        .game-card {
            background: var(--bg-panel);
            border-radius: 8px;
            padding: 14px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .game-card.winner { border-color: var(--accent-gold); }
        .game-card.loser { opacity: 0.5; }
        .game-card.eliminated { border-color: var(--accent); background: rgba(233,69,96,0.1); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .card-name { font-weight: 600; font-size: 0.95rem; }
        .card-score { font-size: 1.5rem; font-weight: 700; color: var(--accent-light); }
        .mini-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 1px;
            background: #000;
            padding: 2px;
            border-radius: 4px;
            aspect-ratio: 1;
        }
        .mini-board .cell { border-radius: 1px; transition: background 0.1s; }
        .mini-board .cell.empty { background: var(--cell-empty); }
        .mini-board .cell.filled { background: var(--cell-filled); }
        .card-stats { display: flex; justify-content: space-between; margin-top: 10px; font-size: 0.72rem; color: var(--text-dim); }
        .card-stat { text-align: center; }
        .card-stat-value { font-size: 0.95rem; font-weight: 600; color: var(--text); }
        .card-explanation {
            margin-top: 10px;
            padding: 8px 10px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.72rem;
            color: var(--accent-green);
            font-family: monospace;
            min-height: 30px;
        }
        .right-panel { background: var(--bg-panel); padding: 16px; border-left: 1px solid var(--border); overflow-y: auto; }
        .panel-title { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 12px; font-weight: 600; }
        .game-info-panel { background: var(--bg-card); border-radius: 6px; padding: 12px; margin-bottom: 16px; }
        .game-info-row { display: flex; justify-content: space-between; font-size: 0.75rem; padding: 4px 0; }
        .game-info-label { color: var(--text-dim); }
        .game-info-value { font-weight: 600; }
        .leaderboard-row { display: flex; align-items: center; gap: 8px; padding: 10px; margin-bottom: 6px; background: var(--bg-card); border-radius: 6px; }
        .lb-rank { width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; border-radius: 50%; font-size: 0.72rem; font-weight: 700; background: var(--text-muted); color: var(--bg-dark); }
        .lb-rank.r1 { background: var(--accent-gold); }
        .lb-rank.r2 { background: #c0c0c0; }
        .lb-rank.r3 { background: #cd7f32; }
        .lb-info { flex: 1; min-width: 0; }
        .lb-name { font-size: 0.82rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .lb-stats { font-size: 0.68rem; color: var(--text-dim); }
        .lb-score { font-weight: 700; color: var(--accent-light); font-size: 0.88rem; }
        .stats-chart { background: var(--bg-card); border-radius: 6px; padding: 12px; margin-top: 16px; }
        .chart-canvas { width: 100%; height: 120px; }
        .winner-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 1000; }
        .winner-overlay.show { display: flex; }
        .winner-card { background: var(--bg-panel); border: 2px solid var(--accent-gold); border-radius: 12px; padding: 36px 56px; text-align: center; animation: popIn 0.3s ease-out; max-width: 500px; }
        @keyframes popIn { 0% { transform: scale(0.9); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .winner-label { font-size: 0.8rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; }
        .winner-name { font-size: 2rem; font-weight: 700; color: var(--accent-gold); margin: 10px 0; }
        .winner-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0; text-align: center; }
        .winner-stat-value { font-size: 1.4rem; font-weight: 700; color: var(--text); }
        .winner-stat-label { font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase; }
        .winner-chart { margin: 20px 0; padding: 12px; background: var(--bg-card); border-radius: 8px; }
        .winner-close { margin-top: 20px; padding: 10px 28px; background: var(--accent-gold); color: #000; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            .sidebar, .right-panel { display: none; }
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>8x8 Strategy Arena</h1>
            <div class="subtitle">Compare AI strategies head-to-head</div>
        </div>
        <div style="color: var(--accent-green); font-size: 0.8rem;">Static Demo</div>
    </header>
    <div class="container">
        <aside class="sidebar">
            <div class="section">
                <div class="section-header">Battle Mode</div>
                <div class="mode-selector">
                    <div class="mode-option selected" data-mode="battle">
                        <div class="mode-radio"></div>
                        <div class="mode-info">
                            <div class="mode-name">Battle Royale</div>
                            <div class="mode-desc">All strategies play the same game simultaneously with identical block sequences. Same RNG seed ensures fair comparison.</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="section">
                <div class="section-header">Strategies (click to select, double-click for details)</div>
                <div class="strategy-list" id="strategy-list"></div>
            </div>
            <div class="section">
                <div class="section-header">Settings</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Games</label>
                        <input type="number" id="num-games" value="5" min="1" max="50">
                    </div>
                    <div class="control-group">
                        <label>Speed</label>
                        <select id="speed">
                            <option value="150">Slow</option>
                            <option value="40" selected>Normal</option>
                            <option value="8">Fast</option>
                            <option value="0">Instant</option>
                        </select>
                    </div>
                </div>
                <button class="btn-primary" id="start-btn">Start Battle</button>
                <button class="btn-secondary" id="stop-btn" disabled>Stop</button>
                <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
            </div>
        </aside>
        <main>
            <div class="battle-grid" id="battle-grid">
                <div style="color: var(--text-dim); text-align: center; padding: 40px;">Select strategies and click Start Battle</div>
            </div>
        </main>
        <aside class="right-panel">
            <div class="panel-title">Current Game</div>
            <div class="game-info-panel">
                <div class="game-info-row"><span class="game-info-label">Game</span><span class="game-info-value" id="current-game">-</span></div>
                <div class="game-info-row"><span class="game-info-label">Turn</span><span class="game-info-value" id="current-turn">-</span></div>
            </div>
            <div class="panel-title">Leaderboard</div>
            <div id="leaderboard"></div>
            <div class="stats-chart">
                <div class="panel-title">Score History</div>
                <canvas id="score-chart" class="chart-canvas"></canvas>
            </div>
        </aside>
    </div>
    <div class="winner-overlay" id="winner-overlay">
        <div class="winner-card">
            <div class="winner-label">Champion</div>
            <div class="winner-name" id="winner-name"></div>
            <div class="winner-stats">
                <div><div class="winner-stat-value" id="winner-wins">0</div><div class="winner-stat-label">Wins</div></div>
                <div><div class="winner-stat-value" id="winner-avg">0</div><div class="winner-stat-label">Avg Score</div></div>
                <div><div class="winner-stat-value" id="winner-high">0</div><div class="winner-stat-label">High Score</div></div>
            </div>
            <div class="winner-chart">
                <canvas id="winner-chart" width="380" height="100"></canvas>
            </div>
            <button class="winner-close" onclick="closeWinner()">Continue</button>
        </div>
    </div>

<script>
// ============================================================================
// GAME ENGINE (Ported from Python)
// ============================================================================

const BLOCKS = {
    line_2h: [[1,1]],
    line_3h: [[1,1,1]],
    line_4h: [[1,1,1,1]],
    line_2v: [[1],[1]],
    line_3v: [[1],[1],[1]],
    line_4v: [[1],[1],[1],[1]],
    line_5v: [[1],[1],[1],[1],[1]],
    square_2x2: [[1,1],[1,1]],
    square_3x3: [[1,1,1],[1,1,1],[1,1,1]],
    L_small_0: [[1,0],[1,1]],
    L_small_90: [[1,1],[1,0]],
    L_small_180: [[1,1],[0,1]],
    L_small_270: [[0,1],[1,1]],
    L_big_0: [[1,0],[1,0],[1,1]],
    L_big_90: [[1,1,1],[1,0,0]],
    L_big_180: [[1,1],[0,1],[0,1]],
    L_big_270: [[0,0,1],[1,1,1]],
    T_shape: [[0,1,0],[1,1,1]],
    S_shape: [[0,1,1],[1,1,0]],
    Z_shape: [[1,1,0],[0,1,1]]
};

const BLOCK_NAMES = Object.keys(BLOCKS);

class SeededRandom {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0) this.seed += 2147483646;
    }
    next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
    }
    choice(arr) {
        return arr[Math.floor(this.next() * arr.length)];
    }
}

class Board {
    constructor() {
        this.grid = Array(8).fill(null).map(() => Array(8).fill(0));
    }
    copy() {
        const b = new Board();
        b.grid = this.grid.map(row => [...row]);
        return b;
    }
    canPlace(shape, row, col) {
        for (let dr = 0; dr < shape.length; dr++) {
            for (let dc = 0; dc < shape[0].length; dc++) {
                if (shape[dr][dc]) {
                    const r = row + dr, c = col + dc;
                    if (r < 0 || r >= 8 || c < 0 || c >= 8 || this.grid[r][c]) return false;
                }
            }
        }
        return true;
    }
    place(shape, row, col) {
        let cells = 0;
        for (let dr = 0; dr < shape.length; dr++) {
            for (let dc = 0; dc < shape[0].length; dc++) {
                if (shape[dr][dc]) {
                    this.grid[row + dr][col + dc] = 1;
                    cells++;
                }
            }
        }
        return cells;
    }
    clearLines() {
        let cleared = 0;
        const rowsToClear = [], colsToClear = [];
        for (let i = 0; i < 8; i++) {
            if (this.grid[i].every(c => c === 1)) rowsToClear.push(i);
            if (this.grid.every(row => row[i] === 1)) colsToClear.push(i);
        }
        for (const r of rowsToClear) {
            for (let c = 0; c < 8; c++) this.grid[r][c] = 0;
            cleared++;
        }
        for (const c of colsToClear) {
            for (let r = 0; r < 8; r++) this.grid[r][c] = 0;
            cleared++;
        }
        return cleared;
    }
    countEmpty() {
        return this.grid.flat().filter(c => c === 0).length;
    }
    countHoles() {
        let holes = 0;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (!this.grid[r][c]) {
                    let blocked = 0;
                    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc]) => {
                        const nr = r+dr, nc = c+dc;
                        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8 || this.grid[nr]?.[nc]) blocked++;
                    });
                    if (blocked >= 3) holes++;
                }
            }
        }
        return holes;
    }
    countNearComplete() {
        let count = 0;
        for (let i = 0; i < 8; i++) {
            if (this.grid[i].reduce((a,b) => a+b, 0) >= 6) count++;
            if (this.grid.reduce((a,row) => a + row[i], 0) >= 6) count++;
        }
        return count;
    }
}

class Game {
    constructor(seed) {
        this.rng = new SeededRandom(seed || Date.now());
        this.board = new Board();
        this.score = 0;
        this.combo = 0;
        this.movesSinceClear = 0;
        this.turn = 0;
        this.gameOver = false;
        this.blocks = this.generateBatch();
    }
    copy() {
        const g = new Game(1);
        g.rng = new SeededRandom(this.rng.seed);
        g.board = this.board.copy();
        g.score = this.score;
        g.combo = this.combo;
        g.movesSinceClear = this.movesSinceClear;
        g.turn = this.turn;
        g.gameOver = this.gameOver;
        g.blocks = [...this.blocks];
        return g;
    }
    generateBatch() {
        return [0,1,2].map(() => this.rng.choice(BLOCK_NAMES));
    }
    getValidMoves() {
        const moves = [];
        for (let bi = 0; bi < this.blocks.length; bi++) {
            if (!this.blocks[bi]) continue;
            const shape = BLOCKS[this.blocks[bi]];
            for (let r = 0; r <= 8 - shape.length; r++) {
                for (let c = 0; c <= 8 - shape[0].length; c++) {
                    if (this.board.canPlace(shape, r, c)) {
                        moves.push({blockIdx: bi, row: r, col: c, shape});
                    }
                }
            }
        }
        return moves;
    }
    makeMove(blockIdx, row, col) {
        const blockName = this.blocks[blockIdx];
        if (!blockName) return null;
        const shape = BLOCKS[blockName];
        if (!this.board.canPlace(shape, row, col)) return null;

        const cells = this.board.place(shape, row, col);
        const lines = this.board.clearLines();

        let points = cells;
        const isMulti = lines >= 2;

        if (lines > 0) {
            for (let i = 0; i < lines; i++) {
                this.combo++;
                if (isMulti) {
                    points += this.combo * 10;
                } else if (this.combo === 1) {
                    points += 10;
                } else {
                    points += 10 + this.combo * 10;
                }
            }
            if (isMulti && this.combo > lines) points += 30;
            this.movesSinceClear = 0;
        } else {
            this.movesSinceClear++;
            if (this.movesSinceClear > 3) this.combo = 0;
        }

        this.score += points;
        this.blocks[blockIdx] = null;
        this.turn++;

        if (this.blocks.every(b => !b)) {
            this.blocks = this.generateBatch();
        }

        if (this.getValidMoves().length === 0) {
            this.gameOver = true;
        }

        return { points, lines, combo: this.combo };
    }
}

// ============================================================================
// STRATEGIES (Curated set of distinct approaches)
// ============================================================================

const STRATEGIES = {
    random: {
        name: "Random",
        short_desc: "Uniformly random move selection",
        algorithm: "Selects a valid move uniformly at random. Serves as baseline for comparison. Expected score reflects pure chance without optimization.",
        complexity: "O(n)",
        category: "Baseline",
        evaluate: (game, move) => Math.random()
    },
    tuned_balanced: {
        name: "Tuned Balanced",
        short_desc: "Multi-factor weighted evaluation",
        algorithm: "Weighted combination of 6 factors tuned through experimentation: immediate_score (1.0), lines_cleared (15.0), combo_bonus (8.0), empty_cells (0.4), future_moves (0.5), holes_penalty (-8.0). Balances short-term scoring with long-term survival.",
        complexity: "O(n * m)",
        category: "Strategic",
        evaluate: (game, move) => {
            const sim = game.copy();
            const r = sim.makeMove(move.blockIdx, move.row, move.col);
            if (!r) return -10000;
            const holes = sim.board.countHoles();
            return r.points * 1 + r.lines * 15 + r.combo * 8 +
                   sim.board.countEmpty() * 0.4 + sim.getValidMoves().length * 0.5 - holes * 8;
        }
    },
    survival_expert: {
        name: "Survival Expert",
        short_desc: "Maximizes longevity and flexibility",
        algorithm: "Primary goal: avoid game over. Evaluates: future_move_count * 3 + empty_cells * 2 + lines_cleared * 25 - holes * 10. Heavily penalizes moves that reduce options below threshold. Clears lines only when safe.",
        complexity: "O(n * m)",
        category: "Defensive",
        evaluate: (game, move) => {
            const sim = game.copy();
            const r = sim.makeMove(move.blockIdx, move.row, move.col);
            if (!r) return -10000;
            const futureCount = sim.getValidMoves().length;
            const empty = sim.board.countEmpty();
            const holes = sim.board.countHoles();
            let score = futureCount * 3 + empty * 2 + r.lines * 25 - holes * 10;
            if (futureCount < 10) score -= (10 - futureCount) * 5;
            if (futureCount === 0) score -= 500;
            return score;
        }
    },
    combo_master: {
        name: "Combo Master",
        short_desc: "Combo-focused with setup awareness",
        algorithm: "Prioritizes building and maintaining combos. Evaluates: combo_level * 25 + lines_cleared * 40 + near_complete_bonus. Looks ahead to find moves that set up future clears. Penalizes moves that waste combo grace period.",
        complexity: "O(n * eval)",
        category: "Aggressive",
        evaluate: (game, move) => {
            const sim = game.copy();
            const r = sim.makeMove(move.blockIdx, move.row, move.col);
            if (!r) return -10000;
            let score = 0;
            if (r.lines > 0) {
                score += r.combo * 25 + r.lines * 40;
                if (r.lines >= 2) score += 60;
            }
            score += sim.board.countNearComplete() * 15;
            if (r.lines === 0 && game.combo > 0 && game.movesSinceClear >= 2) {
                score -= 20;
                if (sim.board.countNearComplete() > 0) score += 10;
            }
            score += sim.board.countEmpty() * 0.2;
            return score;
        }
    },
    deep_lookahead: {
        name: "Deep Lookahead",
        short_desc: "2-ply search with board evaluation",
        algorithm: "Minimax-style 2-ply search. For each move, simulates the result then evaluates all follow-up moves (best 15 sampled). Uses composite evaluation: score_gain + 0.4*best_future + 0.3*empty_cells - 5*holes. Prunes losing branches early.",
        complexity: "O(n * 15 * eval)",
        category: "Search-Based",
        evaluate: (game, move) => {
            const sim = game.copy();
            const r = sim.makeMove(move.blockIdx, move.row, move.col);
            if (!r) return -10000;

            const immediate = r.points;
            const empty = sim.board.countEmpty();
            const holes = sim.board.countHoles();

            const futureMoves = sim.getValidMoves();
            if (futureMoves.length === 0) {
                return immediate - 1000 + empty * 0.3;
            }

            let bestFuture = 0;
            for (let i = 0; i < Math.min(15, futureMoves.length); i++) {
                const fm = futureMoves[i];
                const sim2 = sim.copy();
                const r2 = sim2.makeMove(fm.blockIdx, fm.row, fm.col);
                if (r2) {
                    const futureScore = r2.points + sim2.board.countEmpty() * 0.2 - sim2.board.countHoles() * 3;
                    bestFuture = Math.max(bestFuture, futureScore);
                }
            }

            return immediate + bestFuture * 0.4 + empty * 0.3 - holes * 5;
        }
    }
};

// ============================================================================
// UI STATE
// ============================================================================

let selectedStrategies = new Set(['tuned_balanced', 'survival_expert', 'combo_master', 'deep_lookahead']);
let isRunning = false;
let shouldStop = false;
let gameHistory = {}; // Track scores per game for charting
let allTimeStats = {}; // Track all-time stats

// ============================================================================
// UI FUNCTIONS
// ============================================================================

function renderStrategyList() {
    const list = document.getElementById('strategy-list');
    list.innerHTML = '';
    for (const [id, s] of Object.entries(STRATEGIES)) {
        const item = document.createElement('div');
        item.className = 'strategy-item' + (selectedStrategies.has(id) ? ' selected' : '');
        item.innerHTML = `
            <div class="strategy-header">
                <span class="strategy-name">${s.name}</span>
                <span class="strategy-category">${s.category}</span>
            </div>
            <div class="strategy-short">${s.short_desc}</div>
            <div class="strategy-detail">
                <div>${s.algorithm}</div>
                <div class="strategy-complexity">Complexity: ${s.complexity}</div>
            </div>
        `;
        item.onclick = (e) => {
            if (e.detail === 2) {
                item.classList.toggle('expanded');
            } else {
                if (selectedStrategies.has(id)) {
                    if (selectedStrategies.size > 1) selectedStrategies.delete(id);
                } else {
                    selectedStrategies.add(id);
                }
                renderStrategyList();
            }
        };
        list.appendChild(item);
    }
}

function createGameCard(strategyId) {
    const s = STRATEGIES[strategyId];
    const card = document.createElement('div');
    card.className = 'game-card';
    card.id = `card-${strategyId}`;
    card.innerHTML = `
        <div class="card-header">
            <span class="card-name">${s.name}</span>
            <span class="card-score" id="score-${strategyId}">0</span>
        </div>
        <div class="mini-board" id="board-${strategyId}">
            ${Array(64).fill('<div class="cell empty"></div>').join('')}
        </div>
        <div class="card-stats">
            <div class="card-stat"><div class="card-stat-value" id="combo-${strategyId}">0x</div><div>Combo</div></div>
            <div class="card-stat"><div class="card-stat-value" id="lines-${strategyId}">0</div><div>Lines</div></div>
            <div class="card-stat"><div class="card-stat-value" id="turns-${strategyId}">0</div><div>Turns</div></div>
        </div>
        <div class="card-explanation" id="explain-${strategyId}">Ready</div>
    `;
    return card;
}

function updateBoard(strategyId, grid) {
    const board = document.getElementById(`board-${strategyId}`);
    if (!board) return;
    const cells = board.querySelectorAll('.cell');
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            cells[r * 8 + c].className = 'cell ' + (grid[r][c] ? 'filled' : 'empty');
        }
    }
}

function updateLeaderboard(stats) {
    const rankings = Object.entries(stats)
        .map(([id, s]) => ({ id, ...s, avg: s.games > 0 ? s.totalScore / s.games : 0 }))
        .sort((a, b) => b.wins - a.wins || b.avg - a.avg);

    document.getElementById('leaderboard').innerHTML = rankings.map((r, i) => `
        <div class="leaderboard-row">
            <div class="lb-rank ${i === 0 ? 'r1' : i === 1 ? 'r2' : i === 2 ? 'r3' : ''}">${i + 1}</div>
            <div class="lb-info">
                <div class="lb-name">${STRATEGIES[r.id].name}</div>
                <div class="lb-stats">${r.wins}W | Avg: ${Math.round(r.avg)} | High: ${r.highScore || 0}</div>
            </div>
            <div class="lb-score">${Math.round(r.avg)}</div>
        </div>
    `).join('');
}

function drawScoreChart(history) {
    const canvas = document.getElementById('score-chart');
    const ctx = canvas.getContext('2d');
    const width = canvas.width = canvas.offsetWidth * 2;
    const height = canvas.height = 120 * 2;
    ctx.scale(2, 2);

    ctx.clearRect(0, 0, width/2, height/2);

    const strategies = Object.keys(history);
    if (strategies.length === 0) return;

    const maxScore = Math.max(...strategies.flatMap(s => history[s] || [0])) || 100;
    const colors = {
        random: '#888',
        tuned_balanced: '#4ecdc4',
        survival_expert: '#ffd93d',
        combo_master: '#e94560',
        deep_lookahead: '#6c5ce7'
    };

    const padding = 5;
    const chartWidth = width/2 - padding * 2;
    const chartHeight = height/2 - padding * 2;

    for (const [strategyId, scores] of Object.entries(history)) {
        if (scores.length < 2) continue;
        ctx.beginPath();
        ctx.strokeStyle = colors[strategyId] || '#fff';
        ctx.lineWidth = 1.5;

        scores.forEach((score, i) => {
            const x = padding + (i / (scores.length - 1)) * chartWidth;
            const y = padding + chartHeight - (score / maxScore) * chartHeight;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
}

function drawWinnerChart(history, winnerId) {
    const canvas = document.getElementById('winner-chart');
    const ctx = canvas.getContext('2d');
    const width = 380;
    const height = 100;

    ctx.clearRect(0, 0, width, height);

    const strategies = Object.keys(history);
    if (strategies.length === 0) return;

    const maxScore = Math.max(...strategies.flatMap(s => history[s] || [0])) || 100;
    const colors = {
        random: '#888',
        tuned_balanced: '#4ecdc4',
        survival_expert: '#ffd93d',
        combo_master: '#e94560',
        deep_lookahead: '#6c5ce7'
    };

    for (const [strategyId, scores] of Object.entries(history)) {
        if (scores.length < 2) continue;
        ctx.beginPath();
        ctx.strokeStyle = colors[strategyId] || '#fff';
        ctx.lineWidth = strategyId === winnerId ? 3 : 1;
        ctx.globalAlpha = strategyId === winnerId ? 1 : 0.3;

        scores.forEach((score, i) => {
            const x = (i / (scores.length - 1)) * width;
            const y = height - (score / maxScore) * height;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

function showWinner(strategyId, stats, history) {
    document.getElementById('winner-name').textContent = STRATEGIES[strategyId].name;
    document.getElementById('winner-wins').textContent = stats.wins;
    document.getElementById('winner-avg').textContent = Math.round(stats.totalScore / stats.games);
    document.getElementById('winner-high').textContent = stats.highScore;
    drawWinnerChart(history, strategyId);
    document.getElementById('winner-overlay').classList.add('show');
}

function closeWinner() {
    document.getElementById('winner-overlay').classList.remove('show');
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function runBattle() {
    const strategyIds = Array.from(selectedStrategies);
    const numGames = parseInt(document.getElementById('num-games').value);
    const speed = parseInt(document.getElementById('speed').value);

    const grid = document.getElementById('battle-grid');
    grid.innerHTML = '';
    strategyIds.forEach(id => grid.appendChild(createGameCard(id)));

    const stats = {};
    gameHistory = {};
    strategyIds.forEach(id => {
        stats[id] = { wins: 0, totalScore: 0, games: 0, highScore: 0 };
        gameHistory[id] = [];
    });

    isRunning = true;
    shouldStop = false;
    document.getElementById('start-btn').disabled = true;
    document.getElementById('stop-btn').disabled = false;

    for (let gameNum = 1; gameNum <= numGames && !shouldStop; gameNum++) {
        const seed = Date.now() + gameNum;
        const games = {};
        const totalLines = {};

        strategyIds.forEach(id => {
            games[id] = new Game(seed);
            totalLines[id] = 0;
            document.getElementById(`card-${id}`).classList.remove('winner', 'loser', 'eliminated');
            document.getElementById(`score-${id}`).textContent = '0';
            document.getElementById(`combo-${id}`).textContent = '0x';
            document.getElementById(`lines-${id}`).textContent = '0';
            document.getElementById(`turns-${id}`).textContent = '0';
            document.getElementById(`explain-${id}`).textContent = 'Starting...';
            updateBoard(id, games[id].board.grid);
        });

        document.getElementById('current-game').textContent = `${gameNum} / ${numGames}`;

        let active = new Set(strategyIds);
        let turn = 0;

        while (active.size > 0 && !shouldStop) {
            turn++;
            document.getElementById('current-turn').textContent = turn;

            for (const id of active) {
                const game = games[id];
                if (game.gameOver) {
                    active.delete(id);
                    document.getElementById(`card-${id}`).classList.add('eliminated');
                    document.getElementById(`explain-${id}`).textContent = 'Game Over';
                    continue;
                }

                const moves = game.getValidMoves();
                if (moves.length === 0) {
                    game.gameOver = true;
                    active.delete(id);
                    continue;
                }

                // Evaluate all moves
                const scored = moves.map(m => ({
                    move: m,
                    score: STRATEGIES[id].evaluate(game, m)
                })).sort((a, b) => b.score - a.score);

                const best = scored[0].move;
                const result = game.makeMove(best.blockIdx, best.row, best.col);

                if (result) {
                    totalLines[id] += result.lines;
                    updateBoard(id, game.board.grid);
                    document.getElementById(`score-${id}`).textContent = game.score;
                    document.getElementById(`combo-${id}`).textContent = game.combo + 'x';
                    document.getElementById(`turns-${id}`).textContent = game.turn;
                    document.getElementById(`lines-${id}`).textContent = totalLines[id];

                    let explain = result.lines > 0 ? `+${result.points} (${result.lines}L, ${result.combo}x)` : `+${result.points}`;
                    document.getElementById(`explain-${id}`).textContent = explain;
                }

                if (game.gameOver) {
                    active.delete(id);
                    document.getElementById(`card-${id}`).classList.add('eliminated');
                    document.getElementById(`explain-${id}`).textContent = 'Game Over';
                }
            }

            if (speed > 0) await sleep(speed);
        }

        // Determine winner
        const scores = strategyIds.map(id => ({ id, score: games[id].score }));
        scores.sort((a, b) => b.score - a.score);
        const maxScore = scores[0].score;
        const winners = scores.filter(s => s.score === maxScore);

        strategyIds.forEach(id => {
            const card = document.getElementById(`card-${id}`);
            card.classList.remove('eliminated');
            stats[id].totalScore += games[id].score;
            stats[id].games++;
            stats[id].highScore = Math.max(stats[id].highScore, games[id].score);
            gameHistory[id].push(games[id].score);

            if (games[id].score === maxScore) {
                stats[id].wins++;
                if (winners.length === 1) card.classList.add('winner');
            } else {
                card.classList.add('loser');
            }
        });

        updateLeaderboard(stats);
        drawScoreChart(gameHistory);
        document.getElementById('progress-fill').style.width = (gameNum / numGames * 100) + '%';

        if (gameNum < numGames && !shouldStop) await sleep(400);
    }

    // Final winner
    const finalRankings = Object.entries(stats)
        .map(([id, s]) => ({ id, ...s, avg: s.totalScore / s.games }))
        .sort((a, b) => b.wins - a.wins || b.avg - a.avg);

    if (finalRankings[0].wins > 0 || finalRankings.length > 0) {
        showWinner(finalRankings[0].id, stats[finalRankings[0].id], gameHistory);
    }

    isRunning = false;
    document.getElementById('start-btn').disabled = false;
    document.getElementById('stop-btn').disabled = true;
}

function stopBattle() {
    shouldStop = true;
}

// Initialize
document.getElementById('start-btn').onclick = runBattle;
document.getElementById('stop-btn').onclick = stopBattle;
renderStrategyList();
</script>
</body>
</html>
